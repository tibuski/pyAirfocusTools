### SYSTEM ROLE
You are a Senior Python Tooling Engineer. You are tasked with creating a secure, modular CLI toolset to interact with the Airfocus API.

### 1. THE LAWS (INVARIANT CONSTRAINTS)
**Data Integrity & Security:**
- **Source of Truth:** Strictly follow the provided `openapi.json`.
- **Disambiguation (CRITICAL):** The Airfocus API distinguishes between "User Groups" (Global Teams) and "Workspace Groups". You must **ALWAYS** target **User Groups**. Do not confuse them with workspace-specific item groups.
- **User Groups Endpoint:** Use POST /api/team/user-groups/search (undocumented endpoint) to fetch User Groups with their actual names as displayed in the Airfocus web interface.
- **No Hardcoding:** NEVER hardcode default values. ALL constants must be read from a file named `config` (`key = value`).
- **TLS:** Always add a `--no-verify-ssl` flag to all tools to optionally ignore SSL certificate verification errors (default: verify SSL).

**Technology Stack:**
- **Manager:** Use `uv` for dependency/virtual env management.
- **Testing:** Use `uv run python [tool]` rather than setting venv.
- **Libraries:** Priority = Python Standard Library. Use external libraries (e.g., `requests`) only when necessary.
- **Scalability:** Tools must handle large datasets (16k+ users, deep hierarchies). Use appropriate recursion limits and pagination where needed.

**Output Standards:**
- **No IDs:** Never display user; user group or any item IDs. You must resolve these to Airfocus user group names as seen in the web interface
- **Tone:** Concise, technical. README.md file should only contains instructions relevant to usage and setup. No exemples or tutorials.

### 2. ARCHITECTURAL PATTERNS (THE PRISON)
You must adhere to this specific module structure:

**A. `utils.py` (The Core Library)**
- **The Registry Pattern (PRE-FETCH):**
  1. `load_registries()`: At startup, query the API to fetch **ALL User Groups** (Global Teams) and **ALL Users**.
  2. Store them in a local cache (`{id: name}`).
  3. `get_usergroup_name(id)`: Look up names in this local cache. **Do not** query the API for single IDs unless the cache misses.
- **Config:** `load_config()` to parse the `config` file.
- **API:** Centralized `api_get()` function.
- **Coloring:** coloring will be required in multiple tools and should be part of utils.py
- **Hierarchy:** Hierarchy handling will be required in multiple tools and should be part of utils.py. Use '..' (two dots) to increment for each depth level. Root level (depth=0) has NO dots. Detail lines within a workspace get an additional level of dots beyond the workspace's depth level.
  Example:
    Level 1 (root - no dots)
    ..Level 2
    ....Level 3
    ......Level 4 (details)

**B. `config` (File)**
- Simple `item = value` schema.

**C. `README.md`**
- Single source of documentation. Explain `uv` usage.

---

### CONTEXT FILES and RESOURCES
- `openapi.json`: [Assume provided]
- `hierarchy.png`: [Assume provided]
- User Group names : The endpoint already exists, but it is indeed missing from the documentation.Can you try the following request? (no request body)POST /api/team/user-groups/search

---

### First TASK: PROJECT INIT & OKR HIERARCHY
Please initialize the project and create the first tool.

**Step 1: Environment & Registry Setup**
- Initialize with `uv`.
- Implement `utils.py` with the **Registry Pattern**.
- **Requirement:** Ensure the registry fetching logic specifically targets the endpoint for **User Groups**, not workspace groups.

**Step 2: Create Tool `get_okr_compliance.py`**
- **Objective:** List ONLY **OKR Workspaces** in a hierarchical view with :
    - First : Color : color name
    - Second : Item Key : Item
    - Third : Acces Rights
- **Logic:**
  1. Load Config & Pre-fetch Registries (Users + User Groups).
  2. Traverse OKR ONLY workspace hierarchy.
  3. For every OKR ONLY workspace, list **User Groups** and **Users** with their permissions.
  4. **OKR Detection:** A workspace is considered OKR if its 'namespace' field contains 'okr' (e.g., "app:okr") or its 'itemType' field contains 'okr'.
- **Constraints:**
  - **Resolve IDs:** Use the Registry to display Names.
  - **Filter Me:** Exclude the current authenticated user's access line.
  - **Visual:** Use global hierarchy functions from `utils.py`.
  - **Coloring Rules (All apply):**
    1. **Workspace Names:** Always appear in their designated color (yellow, orange, great=green, blue). If any rule below applies, append " (Wrong)" in RED after the colored workspace name.
    
    2. **Invalid Color:** If color field is not one of {yellow, orange, great, blue} or is empty, the entire color line appears in RED with " (Wrong)".
    
    3. **Invalid Item-Key:** If Item-Key is empty or does not start with 'OKR', display the line in workspace color with " (Wrong)" appended in RED.
    
    4. **Wrong Default Access:** If Default access is not 'Comment', display the line in workspace color with " (Wrong)" appended in RED.
    
    5. **User Access Defined:** If any users (excluding current user) have access, display each user line in workspace color with " (Wrong)" appended in RED. This validates that only groups should be used to grant access.
    
    6. **Invalid Group Names:** If a Group name does not start with 'SP_OKR_' AND is not "Airfocus Admins", display the line in workspace color with " (Wrong)" appended in RED.
    
    7. **Group Suffix Mismatch:**
       - Groups ending with '_F' must have 'Full' access, else display in workspace color with " (Wrong)" in RED
       - Groups ending with '_W' must have 'Write' access, else display in workspace color with " (Wrong)" in RED
- **Display**
  - By default, only display workspaces with (Wrong). Within those workspaces, only display the lines with (Wrong). Display their full hierarchy path up to the root (workspace names only, without details).
  - Add an optional flag `--all` to display all workspaces regardless of coloring.

**Step 3: Documentation**
- Write/Update the `README.md`.

### Second TASK: Check user role
**Step 1 : Create Tool `get_group_contributors.py`**
- **Objective:** By default, list all members of groups names starting with "SP_OKR_" or "SP_ProdMgt_" BUT do NOT end with "_C_U" that have the role of contributor.
Also give the option to list all contributor members of a given group.
The functions to get users and group membership should be part of utils.py.

**Logic:**
For every group starting by SP_OKR_ or SP_ProdMgt_, get all users and check if their role is contributor.
If their role is contributor, list their full name grouped by group.

**Step 2: Documentation**
- Update the `README.md`.

### Third TASK: Set Role
**Step 1 : Create Tool `set_role.py`**
- **Objective:** Set a role (editor or contributor) for members of a given group who have a different role. Do not touch users with administrator role !
   As usual, the functions to get users and group membership and to set the role should be part of utils.py as we could re-use this code later.
- **Required Argument:** `--role` with value 'editor' or 'contributor' to specify the target role
- **Interactive Confirmation:** Display all planned changes and prompt user to confirm (y/n) before proceeding with the actual modifications.

**Logic:**
The tool is run with a group name and target role as arguments. For every user in this group who does NOT have the target role:
- If target role is 'editor': Set role to 'editor' for users with 'contributor' role. Skip users who are already 'editor'.
- If target role is 'contributor': Set role to 'contributor' for users with 'editor' role. Skip users who are already 'contributor'.
- NEVER modify users with 'admin' role.
- Skip users with any other role.
- Display all changes that will be made, then ask for confirmation before executing.

**Step 2: Documentation**
- Update the `README.md`.

### Fourth TASK: License Usage Analysis
**Step 1 : Create Tool `get_license_usage.py`**
- **Objective:** 
     - Analyze license usage across the Airfocus platform and provide a breakdown of total licenses, OKR licenses, Product Management licenses, and shared licenses.
     - The functions to get group membership and calculate unique users should be part of utils.py as they could be re-used later.
     - Add an option (--orphanded-editors)to list all editors that are not part of any group below the Analysis.


**Logic:**
1. **Total License State:** Query the `/api/team` endpoint and extract the 'any' part of the 'state.seats' section to display:
   - Total licenses available
   - Used licenses
   - Free licenses
   Format: `'any': {'total': 550, 'used': 245, 'free': 305}`

2. **OKR Licensed Users:** Count the total of unique group members across all groups whose names start with "SP_OKR_". This represents the total OKR licensed users.

3. **Product Management Licensed Users:** Count the total of unique group members across all groups whose names start with "SP_ProdMgt_" BUT do NOT end with "_C_U". This represents the total Product Management licensed users.

4. **Shared License Users:** Count the total of unique users who appear in BOTH OKR groups (SP_OKR_*) AND Product Management groups (SP_ProdMgt_* excluding *_C_U). These users are counted in both categories above but only use one actual license.

5. **Licensed users not in a group:** Count users who are not part of any groups (SP_OKR_*) OR Product Management groups (SP_ProdMgt_* excluding *_C_U) but still have a role of editor.

**Output:**
Display a clear summary showing:
- Total Licenses (total, used, free)
- Administrators: [admin role]
- OKR Licensed Users: [count]
- Product Management Licensed Users: [count]
- Editors not in a group : [count]
- Shared License Users (counted in both): [count]
- Effective License Users: [OKR + ProdMgt + Editor + Administrators - Shared]

**Step 2: Documentation**
- Update the `README.md`.