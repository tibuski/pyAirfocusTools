### SYSTEM ROLE
You are a Senior Python Tooling Engineer. You are tasked with creating a secure, modular CLI toolset to interact with the Airfocus API.

### 1. THE LAWS (INVARIANT CONSTRAINTS)
**Data Integrity & Security:**
- **Source of Truth:** Strictly follow the provided `openapi.json`.
- **Disambiguation (CRITICAL):** The Airfocus API distinguishes between "User Groups" (Global Teams) and "Workspace Groups". You must **ALWAYS** target **User Groups**. Do not confuse them with workspace-specific item groups.
- **User Groups Endpoint:** Use POST /api/team/user-groups/search (undocumented endpoint) to fetch User Groups with their actual names as displayed in the Airfocus web interface.
- **No Hardcoding:** NEVER hardcode default values. ALL constants must be read from a file named `config` (`key = value`).
- **TLS:** Always add a `--no-verify-ssl` flag to all tools to optionally ignore SSL certificate verification errors (default: verify SSL).

**Technology Stack:**
- **Manager:** Use `uv` for dependency/virtual env management.
- **Testing:** Use `uv run python [tool]` rather than setting venv.
- **Libraries:** Priority = Python Standard Library. Use external libraries (e.g., `requests`) only when necessary.
- **Scalability:** Tools must handle large datasets (16k+ users, deep hierarchies). Use appropriate recursion limits and pagination where needed.

**Output Standards:**
- **No IDs:** Never display user; user group or any item IDs. You must resolve these to Airfocus user group names as seen in the web interface
- **Tone:** Concise, technical. README.md file should only contains instructions relevant to usage and setup. No exemples or tutorials.
- **Help Messages:** ALL tools MUST display a comprehensive help message when:
  - Run without any arguments (automatically show help)
  - Run with `-h` or `--help` flags
  - Run with invalid/missing required arguments
  - Help message format must be consistent across all tools and include:
    * Tool description (what it does)
    * Usage syntax with command examples
    * List of all arguments and options with descriptions
  - Implementation: Use Python's `argparse` module with clear `description` parameter in ArgumentParser
  - For tools with optional positional arguments, ensure help is displayed when no arguments provided (not an error message)

### 2. ARCHITECTURAL PATTERNS (THE PRISON)
You must adhere to this specific module structure:

**A. `utils.py` (The Core Library)**
- **The Registry Pattern (PRE-FETCH):**
  1. `load_registries()`: At startup, query the API to fetch **ALL User Groups** (Global Teams) and **ALL Users**.
  2. Store them in a local cache (`{id: name}`).
  3. `get_usergroup_name(id)`: Look up names in this local cache. **Do not** query the API for single IDs unless the cache misses.
- **Config:** `load_config()` to parse the `config` file.
- **API:** Centralized `api_get()` function.
- **Coloring:** coloring will be required in multiple tools and should be part of utils.py
- **Hierarchy:** Hierarchy handling will be required in multiple tools and should be part of utils.py. Use '..' (two dots) to increment for each depth level. Root level (depth=0) has NO dots. Detail lines within a workspace get an additional level of dots beyond the workspace's depth level.
  Example:
    Level 1 (root - no dots)
    ..Level 2
    ....Level 3
    ......Level 4 (details)

**B. `config` (File)**
- Simple `item = value` schema.

**C. `README.md`**
- Single source of documentation. Explain `uv` usage.

---

### CONTEXT FILES and RESOURCES
- `openapi.json`: [Assume provided]
- `hierarchy.png`: [Assume provided]
- User Group names : The endpoint already exists, but it is indeed missing from the documentation.Can you try the following request? (no request body)POST /api/team/user-groups/search

---

### First TASK: PROJECT INIT & OKR HIERARCHY
Please initialize the project and create the first tool.

**Step 1: Environment & Registry Setup**
- Initialize with `uv`.
- Implement `utils.py` with the **Registry Pattern**.
- **Requirement:** Ensure the registry fetching logic specifically targets the endpoint for **User Groups**, not workspace groups.

**Step 2: Create Tool `get_okr_compliance.py`**
- **Objective:** List ONLY **OKR Workspaces** in a hierarchical view with :
    - First : Color : color name
    - Second : Item Key : Item
    - Third : Acces Rights
- **Logic:**
  1. Load Config & Pre-fetch Registries (Users + User Groups).
  2. Traverse OKR ONLY workspace hierarchy.
  3. For every OKR ONLY workspace, list **User Groups** and **Users** with their permissions.
  4. **OKR Detection:** A workspace is considered OKR if its 'namespace' field contains 'okr' (e.g., "app:okr") or its 'itemType' field contains 'okr'.
- **Constraints:**
  - **Resolve IDs:** Use the Registry to display Names.
  - **Filter Me:** Exclude the current authenticated user's access line.
  - **Visual:** Use global hierarchy functions from `utils.py`.
  - **Coloring Rules (All apply):**
    1. **Workspace Names:** Always appear in their designated color (yellow, orange, great=green, blue). If any rule below applies, append " (Wrong)" in RED after the colored workspace name.
    
    2. **Invalid Color:** If color field is not one of {yellow, orange, great, blue} or is empty, the entire color line appears in RED with " (Wrong)".
    
    3. **Invalid Item-Key:** If Item-Key is empty or does not start with 'OKR', display the line in workspace color with " (Wrong)" appended in RED.
    
    4. **Wrong Default Access:** If Default access is not 'Comment', display the line in workspace color with " (Wrong)" appended in RED.
    
    5. **User Access Defined:** If any users (excluding current user) have access, display each user line in workspace color with " (Wrong)" appended in RED. This validates that only groups should be used to grant access.
    
    6. **Invalid Group Names:** If a Group name does not start with 'SP_OKR_' AND is not "Airfocus Admins", display the line in workspace color with " (Wrong)" appended in RED.
    
    7. **Group Suffix Mismatch:**
       - Groups ending with '_F' must have 'Full' access, else display in workspace color with " (Wrong)" in RED
       - Groups ending with '_W' must have 'Write' access, else display in workspace color with " (Wrong)" in RED
- **Display**
  - By default, only display workspaces with (Wrong). Within those workspaces, only display the lines with (Wrong). Display their full hierarchy path up to the root (workspace names only, without details).
  - Add an optional flag `--all` to display all workspaces regardless of coloring.

**Step 3: Documentation**
- Write/Update the `README.md`.

### Second TASK: Check user role
**Step 1 : Create Tool `get_group_contributors.py`**
- **Objective:** By default, list all members of groups names starting with "SP_OKR_" or "SP_ProdMgt_" BUT do NOT end with "_C_U" that have the role of contributor.
Also give the option to list all contributor members of a given group.
The functions to get users and group membership should be part of utils.py.

**Logic:**
For every group starting by SP_OKR_ or SP_ProdMgt_, get all users and check if their role is contributor.
If their role is contributor, list their full name grouped by group.

**Step 2: Documentation**
- Update the `README.md`.

### Third TASK: Set Role
**Step 1 : Create Tool `set_role.py`**
- **Objective:** Set a role (editor or contributor) for members of a given group OR for orphaned users who have a different role. Do not touch users with administrator role !
   As usual, the functions to get users and group membership and to set the role should be part of utils.py as we could re-use this code later.
- **Required Argument:** `--role` with value 'editor' or 'contributor' to specify the target role
- **Optional Flag:** `--orphaned` to target orphaned users instead of a specific group
- **Interactive Confirmation:** Display all planned changes and prompt user to confirm (y/n) before proceeding with the actual modifications.

**Logic:**
The tool can operate in three modes:

**Mode 1: Group Mode (default)**
- Run with a group name and target role as arguments. For every user in this group who does NOT have the target role:
  - If target role is 'editor': Set role to 'editor' for users with 'contributor' role. Skip users who are already 'editor'.
  - If target role is 'contributor': Set role to 'contributor' for users with 'editor' role. Skip users who are already 'contributor'.
  - NEVER modify users with 'admin' role.
  - Skip users with any other role.
  - Display all changes that will be made, then ask for confirmation before executing.

**Mode 2: Orphaned Users Mode (with `--orphaned` flag)**
- Identifies editors not in SP_OKR_ or SP_ProdMgt_ groups (excluding *_C_U) who have ZERO workspace access AND ZERO folder access
- Fetches all workspaces and folders once to analyze access (performance optimized)
- Only targets truly orphaned users (no direct workspace or folder permissions)
- Displays each user with confirmation prompt before applying role changes
- Useful for downgrading licenses of unused accounts
- Cannot be combined with group_name argument

**Mode 3: Group Contributors Mode (with `--group-contributors` flag)**
- Targets all users who have the 'contributor' role across all SP_OKR_/SP_ProdMgt_ groups (excluding *_C_U)
- Useful for bulk upgrading contributors to editors across all groups
- Fetches all contributors using the same logic as get_group_contributors.py
- Only modifies users with 'contributor' role (when target is 'editor') or 'editor' role (when target is 'contributor')
- NEVER modifies users with 'admin' role
- Displays all planned changes with group membership information, then asks for confirmation before executing
- Cannot be combined with group_name or --orphaned arguments
- Designed to work with the output concept of get_group_contributors.py (all contributors across managed groups)

**Step 2: Documentation**
- Update the `README.md`.

### Fourth TASK: License Usage Analysis
**Step 1 : Create Tool `get_license_usage.py`**
- **Objective:** 
     - Analyze license usage across the Airfocus platform and provide a breakdown of total licenses, OKR licenses, Product Management licenses, and shared licenses.
     - The functions to get group membership and calculate unique users should be part of utils.py as they could be re-used later.
     - Add an option (--orphanded-editors)to list all editors that are not part of any group below the Analysis.


**Logic:**
1. **Total License State:** Query the `/api/team` endpoint and extract the 'any' part of the 'state.seats' section to display:
   - Total licenses available
   - Used licenses
   - Free licenses
   Format: `'any': {'total': 550, 'used': 245, 'free': 305}`

2. **OKR Licensed Users:** Count the total of unique group members across all groups whose names start with "SP_OKR_". This represents the total OKR licensed users.

3. **Product Management Licensed Users:** Count the total of unique group members across all groups whose names start with "SP_ProdMgt_" BUT do NOT end with "_C_U". This represents the total Product Management licensed users.

4. **Shared License Users:** Count the total of unique users who appear in BOTH OKR groups (SP_OKR_*) AND Product Management groups (SP_ProdMgt_* excluding *_C_U). These users are counted in both categories above but only use one actual license.

5. **Licensed users not in a group:** Count users who are not part of any groups (SP_OKR_*) OR Product Management groups (SP_ProdMgt_* excluding *_C_U) but still have a role of editor.

**Output:**
Display a clear summary showing:
- Total Licenses (total, used, free)
- Administrators: [admin role]
- OKR Licensed Users: [count]
- Product Management Licensed Users: [count]
- Editors not in a group : [count]
- Shared License Users (counted in both): [count]
- Effective License Users: [OKR + ProdMgt + Editor + Administrators - Shared]

**Step 2: Documentation**
- Update the `README.md`.

### Fifth TASK: Product Management Workspace Compliance
**Step 1: Create Tool `get_prodmgt_compliance.py`**
- **Objective:** List ONLY **Non-OKR Workspaces** in a hierarchical view with:
    - First: Color : color name (display only, no validation)
    - Second: Item Key : Item (display only, no validation)
    - Third: Default Access (display only, no validation)
    - Fourth: Access Rights (validate groups)
- **Logic:**
  1. Load Config & Pre-fetch Registries (Users + User Groups).
  2. Traverse Product Management workspace hierarchy.
  3. For every Product Management workspace AND every folder, list **User Groups** and **Users** with their permissions.
  4. **Product Management Detection:** A workspace is considered Product Management if it is NOT an OKR workspace. Reuse the `is_okr_workspace()` function from `get_okr_compliance.py` and invert the logic (i.e., `not is_okr_workspace(workspace)`).
  5. **Hierarchy Structure:** Non-OKR workspaces use FOLDER-BASED hierarchy, not parent-child workspace relationships. Use the `build_folder_hierarchy()` function from `utils.py` to properly organize and display these workspaces by their folder structure. Folders are displayed in the hierarchy and their permissions are validated using the same rules as workspaces.
     
     **Implementation:** The function fetches all workspace groups (folders) using `/api/workspaces/groups/search`, then retrieves full details with embedded data (including workspaces and permissions) using `/api/workspaces/groups/list` in a single batch request. This provides workspace-to-folder assignments via the `_embedded.workspaces` array in each folder's response.
- **Constraints:**
  - **Resolve IDs:** Use the Registry to display Names.
  - **Filter Me:** Exclude the current authenticated user's access line.
  - **Visual:** Use global hierarchy functions from `utils.py`. Folders create the hierarchy levels.
  - **Coloring Rules (All apply to BOTH folders and workspaces):**
    1. **Folder/Workspace Names:** 
       - Folders: Always displayed with a üìÅ folder icon prefix and in yellow color (representing the yellow-orange color of Windows folders)
       - Workspaces: Always appear in their designated color (yellow, orange, great=green, blue)
       - If any rule below applies, append " (Wrong)" in RED after the colored name.
    
    2. **Color, Item Key, Default Access:** Display these fields for information only (workspaces only - folders don't have these). No validation performed. Color is still used to determine the display color for workspace details.
    
    3. **User Access Defined:** If any users (excluding current user) have access to a folder or workspace, display each user line in workspace color with " (Wrong)" appended in RED. This validates that only groups should be used to grant access.
    
    4. **Invalid Group Names:** If a Group name does not start with 'SP_ProdMgt_' AND is not "Airfocus Admins", display the line in workspace/folder color with " (Wrong)" appended in RED.
    
    5. **Group Suffix Mismatch:**
       - Groups ending with '_F_U' must have 'Full' access, else display in workspace/folder color with " (Wrong)" in RED
       - Groups ending with '_W_U' must have 'Write' access, else display in workspace/folder color with " (Wrong)" in RED
       - Groups ending with '_C_U' must have 'Comment' access, else display in workspace/folder color with " (Wrong)" in RED
- **Display**
  - By default, only display workspaces/folders with (Wrong). Within those items, only display the lines with (Wrong). Display their full hierarchy path up to the root (names only, without details).
  - Add an optional flag `--all` to display all workspaces and folders regardless of coloring.

**Step 2: Documentation**
- Update the `README.md`.

### Sixth TASK: Field Options Management
**Step 1: Create Tool `set_field_options.py`**
- **Objective:** Manage custom field options for Airfocus select/dropdown fields via CLI. Support viewing, adding, and reordering options.
- **Functionality:**
  - **View Mode:** When provided only a field name, fetch all existing options for that field, display them to the console (numbered list), and save them to `field_[field name without blank spaces]_options.txt`, one option per line.
  - **Add Mode:** If a text file is provided as input (without `--reorder`), first save the current options to `field_[field name without blank spaces]_options.txt`, then add only the new options (those not already present) from the input file to the field. **The order of new options in the input file is preserved when adding them.**
  - **Reorder Mode:** If `--reorder` flag is used with input file, reorder existing options based on the order in the input file. Options not in the input file are appended at the end. All option IDs are preserved (safe operation).
  - **Show IDs:** Optional `--show-ids` flag displays option IDs alongside names in format: `Name [ID: xyz]`
  - **Confirmation:** Before making any changes (adding or reordering options), display a summary and prompt the user to confirm (y/n).
  - **Help:** If run without arguments, display a help message describing usage and options.
- **Arguments:**
  - `--field FIELD_NAME` (required): The name of the field to manage.
  - `--input FILE` (optional): Path to a text file containing options (one per line).
  - `--reorder` (optional): Reorder existing options based on input file order (requires `--input`).
  - `--show-ids` (optional): Display option IDs alongside option names.
  - `--no-verify-ssl` (optional): Ignore SSL certificate verification errors.
- **Logic:**
  1. Load config and pre-fetch registries as per standard pattern.
  2. Validate that `--reorder` is only used with `--input`.
  3. Check if field type supports options (select/dropdown types only).
  4. **View Mode** (only `--field`): Fetch all current options, display to console (with optional IDs if `--show-ids`), and write names to `field_[field name without blank spaces]_options.txt`.
  5. **Add Mode** (`--input` without `--reorder`): Fetch and save current options, read input file, compare, and add only new options in the order they appear in the input file (preserve input file order). Before adding, display the new options to be added and ask for confirmation.
  6. **Reorder Mode** (`--input` + `--reorder`): Fetch current options, read input file, build new order based on input file, show preview of new order, ask for confirmation, then update field with reordered options (preserving all option IDs).
  7. All API interactions and field option management logic must be implemented in `utils.py` for reuse.
- **API Understanding:**
  - Options are structured objects: `{id, name, description, default, color?, numericValue?}`
  - Options array order in API determines display order
  - Use `GET /api/fields/{fieldId}` to fetch full field configuration
  - Use `PUT /api/fields/{fieldId}` (reconfigureField) to update field with new/reordered options
  - New option IDs are generated sequentially from highest existing ID
  - Reordering preserves all existing option IDs
- **Constraints:**
  - Never hardcode field names or option values.
  - Always resolve field names to IDs using field search.
  - All output files must be plain text, UTF-8 encoded, with one option per line (names only, no IDs in file).
  - Preserve order from input file when adding new options.
  - Preserve all option IDs when reordering.
  - Follow all global architectural and security rules.
- **Output:**
  - Console display of current options (numbered, with optional IDs).
  - Summary of actions taken (options fetched, options added with count, options reordered with count, file written).
  - File saved to `field_[field name without blank spaces]_options.txt`.

**Step 2: Documentation**
- Update the `README.md`.